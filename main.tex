\documentclass[doublespacing,12pt,oneside]{article}
\usepackage[top=2.5cm, left=2.5cm, right=2.5cm, bottom=2.5cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-nodecimaldot,es-tabla]{babel}
\usepackage{caption, subcaption}
\usepackage{graphicx}
\usepackage{imakeidx}
\usepackage{biblatex}
\usepackage{float}
\addbibresource{bib/protocolo.bib}
\addbibresource{biblio.bib}
\graphicspath{{./figs/}}
\usepackage{setspace}
\begin{document}
\tableofcontents

\section{Introducción}

\subsection{Planteamiento del Problema}
En esta práctica se aborda el análisis y representación estructural y dinámica de una aplicación desarrollada en Dart, con énfasis en la elaboración de diagramas UML y en la interpretación del manejo de excepciones implementando en el código base proporcionado. El problema central consiste en comprender la arquitectura del programa, identificar las relaciones entre las clases, describir el flujo de ejecución y explicar el papel que desempeña el control de errores dentro de la solución.

\subsection{Motivación}
La necesidad de resolver este problema radica en que la programación orientada a objetos exige no solo la correcta implementación del código, sino también la capacidad de modelar y documentar los componentes del sistema de manera clara. La representación UML facilita la lectura, el mantenimiento y la escalabilidad del software, mientras que el análisis del manejo de excepciones permite evaluar la solidez y robustez de la aplicación frente a condiciones inesperadas. 

\subsection{Objetivos}
El objetivo principal de esta práctica es generar un reporte técnico que describa la estructura del programa mediante un diagrama UML estático, ilustre su comportamiento mediante un diagrama UML dinámico e interprete los conceptos teóricos aplicados, destacando el mecanismo de excepciones empleado en la solución. Con ello se busca consolidar la habilidad de analizar, modelar y documentar software conforme a los lineamientos establecidos para la elaboración de reportes académicos.

\section{Marco Teórico}

\subsection{Abstracción}
La abstracción es un principio fundamental de la POO que consiste en enfocarse en las características esenciales de un objeto, descartando la información que no es relevante en un contexto particular, para así gestionar la complejidad del sistema. Permite a los desarrolladores construir sistemas complejos de manera más sencilla y organizada, ofreciendo una representación simplificada de la realidad o de un concepto subyacente \cite{ecosistemabuap2023poo}.

\subsection{Encapsulamiento}
El encapsulamiento se refiere a la práctica de agrupar los datos (atributos) y los métodos (comportamientos) que operan sobre esos datos en una única unidad, conocida como clase. Además, permite limitar el acceso directo a los datos (protección de datos), ocultando los detalles de implementación interna de un objeto y exponiendo solo la información necesaria a través de interfaces públicas (métodos), lo que protege la integridad de los datos y facilita la mantenibilidad del código \cite{ferestrepoca2023poo}.

\subsection{Herencia}
La herencia es un mecanismo de la POO que posibilita la creación de nuevas clases (subclases o clases hijas) a partir de clases existentes (superclases o clases padres). La subclase hereda automáticamente los atributos y métodos de su superclase, permitiendo la reutilización de código, la especialización de objetos y la definición de una jerarquía entre clases \cite{coderslink2023poo}.

\subsection{Polimorfismo}
El polimorfismo es la habilidad de un objeto de tomar diferentes formas o de realizar una acción de diferentes maneras, dependiendo del contexto o del objeto específico. Permite que comportamientos diferentes, asociados a objetos distintos, compartan el mismo nombre, logrando flexibilidad y compatibilidad de objetos en el diseño de software. Se implementa comúnmente mediante la sobrecarga y la sobrescritura de métodos \cite{openwebinars2023java}.

\subsection{Dart}
Dart es un lenguaje de programación moderno, de código abierto y orientado a objetos desarrollado por Google. Es un lenguaje puramente orientado a objetos, basado en clases, diseñado con un enfoque en la facilidad de uso y la familiaridad para la mayoría de los programadores. Es conocido por ser un lenguaje optimizado para el cliente, lo que lo hace ideal para la creación de aplicaciones multiplataforma. Las aplicaciones Dart se ejecutan utilizando la Máquina Virtual Dart, que permite la compilación Just-In-Time (JIT) para desarrollo y la compilación Ahead-Of-Time (AOT) para producción \cite{creapolis2023dart}.

\subsection{Flutter}
Flutter es un kit de desarrollo de software (SDK) de interfaz de usuario (UI) de código abierto creado por Google. Se utiliza para desarrollar aplicaciones multiplataforma para sistemas operativos como Android, iOS, Windows, Mac, Linux y la web, utilizando una única base de código. Flutter se basa en el lenguaje Dart y emplea un framework reactivo moderno con un extenso conjunto de widgets de diseño específico que permiten crear una UI consistente y de alto rendimiento. Su motor de renderizado, escrito en C++, utiliza la biblioteca gráfica Skia de Google para el renderizado de bajo nivel \cite{dart2025exceptions}.

\subsection{Manejo de Excepciones}
El manejo de excepciones es un mecanismo que permite gestionar errores y situaciones excepcionales de manera controlada durante la ejecución de un programa. En Dart, todas las excepciones derivan de la clase \texttt{Exception} y se utilizan para separar el flujo normal del programa del manejo de condiciones de error, mejorando así la robustez y mantenibilidad del software \cite{dart2025exceptions}.

\subsection{Diagramas UML}
El Lenguaje Unificado de Modelado (UML) es un estándar para visualizar, especificar, construir y documentar artefactos de sistemas de software \cite{fowler2004uml}.

\subsubsection{Diagrama UML Estático}
El diagrama de clases representa la estructura del sistema, mostrando:
\begin{itemize}
    \item Interfaz \texttt{ServicioTaller} con métodos abstractos
    \item Clase abstracta \texttt{Vehiculo} que implementa la interfaz
    \item Clases concretas: \texttt{Auto}, \texttt{Moto}, \texttt{Camión}
    \item Relaciones de herencia y realización
\end{itemize}

\subsubsection{Diagrama UML Dinámico}
El diagrama de secuencia muestra las interacciones temporales durante el registro de vehículos, incluyendo:
\begin{itemize}
    \item Flujo normal de creación de objetos
    \item Propagación y captura de excepciones
    \item Validaciones en setters y constructores
\end{itemize}

\section{Desarrollo}


\subsection{Análisis del Código}

\subsubsection{Interpretación del Concepto de Excepciones}

Las excepciones en el programa sirven para manejar situaciones que no estaban planeadas y que pueden provocar que el código falle de manera inesperada. En términos simples, una excepción es como una señal que avisa que algo salió mal y que el programa necesita una forma especial de responder para no detenerse por completo.

En el código analizado, las excepciones ayudan a mantener ordenada la lógica, porque separan lo que hace el programa normalmente de lo que debe hacer cuando ocurre un error. Esto evita estar comprobando manualmente cada posible fallo, ya que el propio lenguaje detecta el problema y permite reaccionar de inmediato.

El uso de bloques como \texttt{try--catch} demuestra que el programa está preparado para enfrentar errores. Cuando algo no funciona —por ejemplo, un dato inválido o una operación incorrecta— el \texttt{catch} permite que el programa siga funcionando sin cerrarse y muestra un mensaje o realiza otra acción que ayude a manejar la situación.

Además, trabajar con excepciones hace más fácil encontrar de dónde viene el error y corregirlo después, porque el manejo está más organizado y centralizado. En general, este mecanismo hace que el programa sea más estable, más claro y capaz de recuperarse cuando ocurre algo inesperado.

\subsubsection{Uso de Herencia}
El código emplea herencia para reutilizar comportamientos comunes entre clases relacionadas. Esto permite que las clases derivadas extiendan la funcionalidad base sin reescribir código, lo cual mejora la cohesión del sistema. La herencia también actúa como fundamento para otras características, como el polimorfismo y la sobrescritura de métodos.

\subsubsection{Polimorfismo}
El polimorfismo se observa cuando múltiples clases comparten una misma interfaz de comportamiento, permitiendo que un mismo método invoque acciones diferentes dependiendo de la instancia concreta utilizada. Este mecanismo facilita que el programa sea expandible, pues nuevas clases pueden integrarse sin necesidad de modificar el código existente que trabaja sobre tipos más generales.

\subsubsection{Sobrescritura de Métodos}
En varias clases se emplea la sobrescritura para modificar o especializar el comportamiento definido en clases superiores. Esto permite que cada clase concreta implemente su propia versión de métodos compartidos, respetando la estructura de la superclase pero adaptándose a las necesidades particulares de cada entidad.

\subsubsection{Encapsulamiento}
El encapsulamiento está presente mediante el uso de atributos privados o protegidos, gestionados a través de métodos públicos. Esto evita la manipulación directa del estado interno de los objetos, garantizando mayor seguridad lógica y evitando inconsistencias. La gestión del estado mediante getters y setters también ayuda a centralizar la validación de datos.

\subsubsection{Modularidad y Separación de Responsabilidades}
Cada clase del código está diseñada para cumplir una responsabilidad específica, lo que sigue el principio \textit{Single Responsibility}. Esto permite localizar problemas y modificar componentes sin afectar al resto del sistema. El uso de archivos separados para cada módulo mejora la organización del proyecto.

\subsubsection{Interacción entre Objetos}
Las clases mantienen comunicación mediante composición y agregación; es decir, algunas clases contienen instancias de otras. Esto permite construir estructuras complejas a partir de componentes simples, promoviendo un diseño escalable y flexible.

\subsubsection{Gestión de Flujo y Lógica de Negocio}
La lógica del programa se distribuye de manera ordenada entre las clases, permitiendo que el flujo de ejecución sea claro. Se integran decisiones, operaciones y cálculos que responden al propósito del proyecto sin saturar las clases con tareas excesivas.

\subsection{Diagramas UML}
\begin{figure}[h]
    \centering
  \includegraphics[width=\textwidth]{capturas/clases.drawio (1).png}
    \caption{Diagrama de clases}
    \label{fig:miimagen}
\end{figure}
\clearpage

\begin{figure}[h]
    \centering
  \includegraphics[width=\textwidth]{capturas/Diagrama dinamico main.PNG}
    \caption{Diagrama de dinamico del main}
    \label{fig:miimagen}
\end{figure}
\clearpage


\subsection{Pruebas}
\clearpage

\section{Resultados} % - - - - - - - - - - - - section - - - - - - - - - - - -
\clearpage

\section{Conclusiones}
El análisis realizado permitió identificar con claridad la estructura interna del programa y representar sus componentes mediante un diagrama UML estático, lo que evidencia las clases definidas, sus atributos, métodos y relaciones. Asimismo, el diagrama UML dinámico permitió describir el flujo de ejecución y la interacción entre objetos durante la operación de la aplicación. A partir de esta representación, fue posible interpretar con precisión los conceptos de programación orientada a objetos aplicados en el código dart.main aportado.

El estudio del manejo de excepciones mostró su relevancia como mecanismo para mantener la estabilidad del programa ante situaciones no previstas durante la ejecución. La forma en que se implementaron dentro del código ejemplifica cómo el lenguaje Dart permite capturar y gestionar errores de forma controlada, garantizando un funcionamiento seguro y predecible. En conjunto, los resultados obtenidos confirman la importancia de emplear modelos UML y técnicas adecuadas de control de errores para desarrollar aplicaciones estructuradas, comprensibles y resistentes a fallos.
\clearpage
\printbibliography

\end{document}
